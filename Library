local InputService = game:GetService('UserInputService');
local TextService = game:GetService('TextService');
local TweenService = game:GetService('TweenService');
local CoreGui = game:GetService('CoreGui');
local RunService = game:GetService('RunService')
local RenderStepped = RunService.RenderStepped;
localJogadorLocal = jogo:GetService('Jogadores').JogadorLocal;
local Mouse = LocalPlayer:GetMouse();

local ProtectGui = protectgui ou (syn e syn.protect_gui) ou (function() end);

local ScreenGui = Instance.new('ScreenGui');
ProtectGui(ScreenGui);

ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Global;
ScreenGui.Parent = CoreGui;

local Alterna = {};
opções locais = {};

getgenv().Toggles = Alterna;
getgenv().Options = Opções;

Biblioteca local = {
    Registro = {};
    RegistryMap = {};

    HudRegistry = {};

    FontColor = Color3.fromRGB(248 , 248, 255);
    MainColor = Color3.fromRGB(20, 20, 20);
    BackgroundColor = Color3.fromRGB(20, 20, 20);
    AccentColor = Color3.fromRGB(255 , 20 , 147);
    OutlineColor = Color3.fromRGB(255 , 20 , 147);

    Preto = Cor3.new(0, 0, 0);

    Quadros Abertos = {};

    Sinais = {};
    TelaGui = TelaGui;
};

local RainbowStep = 0
matiz local = 0

table.insert(Library.Signals, RenderStepped:Connect(function(Delta)
    RainbowStep = RainbowStep + Delta

    se RainbowStep >= (1/60) então
        RainbowStep = 0

        Matiz = Matiz + (1/400);

        se Matiz > 1 então
            Matiz = 0;
        fim;

        Library.CurrentRainbowHue = Matiz;
        Library.CurrentRainbowColor = Color3.fromHSV(Hue, 0.8, 1);
    fim
fim))

biblioteca de funções:AttemptSave()
    se Library.SaveManager então
        Library.SaveManager:Salvar();
    fim;
fim;

Biblioteca de funções:Criar(Classe, Propriedades)
    local _Instância = Classe;

    if type(Classe) == 'string' então
        _Instance = Instância.new(Classe);
    fim;

    para Property, Value in next, Properties do
        _Instance[Propriedade] = Valor;
    fim;

    return _Instância;
fim;

biblioteca de funções:CreateLabel(Propriedades, IsHud)
    local _Instance = Biblioteca:Create('TextLabel', {
        BackgroundTransparency = 1;
        Fonte = Enum.Font.Code;
        TextColor3 = Biblioteca.FontColor;
        TextSize = 16;
        TextStrokeTransparency = 0;
    });

    Biblioteca:AddToRegistry(_Instance, {
        TextColor3 = 'FontColor';
    }, IsHud);

    return Library:Create(_Instance, Properties);
fim;

biblioteca de funções: MakeDraggable (instância, corte)
    Instância.Ativo = verdadeiro;

   Instance.InputBegan:Connect(function(Input)
        se Input.UserInputType == Enum.UserInputType.MouseButton1 então
            local ObjPos = Vector2.new(
                Mouse.X - Instance.AbsolutePosition.X,
                Mouse.Y - Instance.AbsolutePosition.Y
            );

            se ObjPos.Y > (Cutoff ou 40) então
                Retorna;
            fim;

            while InputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1) faça
                Instance.Position = UDim2.new(
                    0,
                    Mouse.X - ObjPos.X + (Instance.Size.X.Offset * Instance.AnchorPoint.X),
                    0,
                    Mouse.Y - ObjPos.Y + (Instance.Size.Y.Offset * Instance.AnchorPoint.Y)
                );

                RenderStepped:Wait();
            fim;
        fim;
    fim)
fim;

biblioteca de funções:AddToolTip(InfoStr, HoverInstance)
    local X, Y = Library:GetTextBounds(InfoStr, Enum.Font.Code, 14);
    Dica de ferramenta local = Biblioteca:Create('Frame', {
        BackgroundColor3 = Biblioteca.MainColor,        
        BorderColor3 = Library.OutlineColor,

        Tamanho = UDim2.fromOffset(X + 5, Y + 4),
        ZIndex = 11;
        Pai = Library.ScreenGui,

        Visível = falso,
    })

    local Label = Biblioteca:CreateLabel({
        Posição = UDim2.fromOffset(3, 1),
        Tamanho = UDim2.fromOffset(X, Y);
        TextSize = 14;
        Texto = InfoStr,
        TextColor3 = Biblioteca.FontColor,
        TextXAlignment = Enum.TextXAlignment.Left;
        ZIndex = 12;

        Pai = dica de ferramenta;
    });

    Biblioteca:AddToRegistry(Tooltip, {
        BackgroundColor3 = 'MainColor';
        BorderColor3 = 'Cor do Contorno';
    });

    Biblioteca:AddToRegistry(Label, {
        TextColor3 = 'FontColor',
    });

    local IsHovering = false
    HoverInstance.MouseEnter:Connect(function()
        Está pairando = verdadeiro
        
        Tooltip.Position = UDim2.fromOffset(Mouse.X + 15, Mouse.Y + 12)
        Tooltip.Visible = verdadeiro

        enquanto está pairando, faça
            RunService.Heartbeat:Wait()
            Tooltip.Position = UDim2.fromOffset(Mouse.X + 15, Mouse.Y + 12)
        fim
    fim)

    HoverInstance.MouseLeave:Connect(function()
        IsHovering = false
        Tooltip.Visible = false
    fim)
fim

biblioteca de funções:OnHighlight(HighlightInstance, Instance, Properties, PropertiesDefault)
    HighlightInstance.MouseEnter:Connect(function()
        local Reg = Library.RegistryMap[Instance];

        para Propriedade, ColorIdx em seguida, Propriedades do
            Instância[Propriedade] = Biblioteca[ColorIdx] ou ColorIdx;

            se Reg e Reg.Propriedades[Propriedade] então
                Reg.Properties[Propriedade] = ColorIdx;
            fim;
        fim;
    fim)

    HighlightInstance.MouseLeave:Connect(function()
        local Reg = Library.RegistryMap[Instance];

        para Property, ColorIdx em seguida, PropertiesDefault do
            Instância[Propriedade] = Biblioteca[ColorIdx] ou ColorIdx;

            se Reg e Reg.Propriedades[Propriedade] então
                Reg.Properties[Propriedade] = ColorIdx;
            fim;
        fim;
    fim)
fim;

biblioteca de funções:MouseIsOverOpenedFrame()
    for Frame, _ in next, Library.OpenedFrames do
        local AbsPos, AbsSize = Frame.AbsolutePosition, Frame.AbsoluteSize;

        se Mouse.X >= AbsPos.X e Mouse.X <= AbsPos.X + AbsSize.X
            e Mouse.Y >= AbsPos.Y e Mouse.Y <= AbsPos.Y + AbsSize.Y então

            retornar verdadeiro;
        fim;
    fim;
fim;

biblioteca de funções:MapValue(Value, MinA, MaxA, MinB, MaxB)
    return (1 - ((Valor - MinA) / (MaxA - MinA))) * MinB + ((Valor - MinA) / (MaxA - MinA)) * MaxB;
fim;

Biblioteca de funções:GetTextBounds(Texto, Fonte, Tamanho, Resolução)
    local Bounds = TextService:GetTextSize(Texto, Tamanho, Fonte, Resolução ou Vetor2.new(1920, 1080))
    retornar Bounds.X, Bounds.Y
fim;

biblioteca de funções: GetDarkerColor(Color)
    local H, S, V = Color3.toHSV(Color);
    return Color3.fromHSV(H, S, V / 1.5);
fim;
Library.AccentColorDark = Biblioteca:GetDarkerColor(Library.AccentColor);

Biblioteca de funções:AddToRegistry(Instância, Propriedades, IsHud)
    Idx local = #Library.Registry + 1;
    dados locais = {
        Instância = Instância;
        Propriedades = Propriedades;
        Idx = Idx;
    };

    table.insert(Library.Registry, Data);
    Library.RegistryMap[Instance] = Dados;

    se é Hud então
        table.insert(Library.HudRegistry, Dados);
    fim;
fim;

biblioteca de funções:RemoveFromRegistry(Instance)
    Dados locais = Library.RegistryMap[Instance];

    se dados então
        para Idx = #Library.Registry, 1, -1 faça
            if Library.Registry[Idx] == Data então
                table.remove(Library.Registry, Idx);
            fim;
        fim;

        para Idx = #Library.HudRegistry, 1, -1 faça
            if Library.HudRegistry[Idx] == Dados então
                table.remove(Library.HudRegistry, Idx);
            fim;
        fim;

        Library.RegistryMap[Instance] = nil;
    fim;
fim;

biblioteca de funções:UpdateColorsUsingRegistry()
    -- TODO: Pode ter uma lista 'ativa' de objetos
    -- onde a lista ativa contém apenas objetos Visíveis.

    -- IMPL: Poderia configurar eventos .Changed na função AddToRegistry
    -- que escuta a propriedade 'Visible' sendo alterada.
    -- Visível: verdadeiro => Adicionar à lista ativa e chamar a função UpdateColors
    -- Visível: false => Remover da lista ativa.

    -- O acima seria especialmente eficiente para uma cor de menu de arco-íris ou mudança de cor ao vivo.

    para Idx, Object in next, Library.Registry faça
        para Property, ColorIdx em seguida, Object.Properties do
            if type(ColorIdx) == 'string' então
                Object.Instance[Propriedade] = Biblioteca[ColorIdx];
            elseif type(ColorIdx) == 'função' então
                Object.Instance[Propriedade] = ColorIdx()
            fim
        fim;
    fim;
fim;

biblioteca de funções:GiveSignal(Signal)
    -- Usado apenas para sinais não anexados a instâncias de biblioteca, pois eles devem ser limpos na destruição de objetos pela Roblox
    table.insert(Library.Signals, Signal)
fim

Biblioteca de funções: Descarregar ()
    -- Descarregue todos os sinais
    para Idx = #Library.Signals, 1, -1 faça
        Conexão local = table.remove(Library.Signals, Idx)
        Conexão: Desconectar()
    fim

     -- Chame nosso retorno de chamada de descarga, talvez para desfazer alguns ganchos, etc.
    se Library.OnUnload então
        Library.OnUnload()
    fim

    ScreenGui:Destroy()
fim

biblioteca de funções:OnUnload(Callback)
    Library.OnUnload = retorno de chamada
fim

Library:GiveSignal(ScreenGui.DescendantRemoving:Connect(function(Instance)
    se Library.RegistryMap[Instance] então
        Biblioteca:RemoveFromRegistry(Instance);
    fim;
fim))

locais BaseAddons = {};

Faz
    funções locais = {};

    função Funcs:AddColorPicker(Idx, Info)
        local ToggleLabel = self.TextLabel;
        local Container = self.Container;

        local ColorPicker = {
            Valor = Info.Padrão;
            Tipo = 'ColorPicker';
            Title = type(Info.Title) == 'string' e Info.Title ou 'Color picker',
        };

        função ColorPicker:SetHSVFromRGB(Color)
            local H, S, V = Color3.toHSV(Color);

            ColorPicker.Hue = H;
            ColorPicker.Sat = S;
            ColorPicker.Vib = V;
        fim;

        ColorPicker:SetHSVFromRGB(ColorPicker.Value);

        local DisplayFrame = Library:Create('Frame', {
            BackgroundColor3 = ColorPicker.Value;
            BorderColor3 = Biblioteca:GetDarkerColor(ColorPicker.Value);
            BorderMode = Enum.BorderMode.Inset;
            Tamanho = UDim2.new(0, 28, 0, 14);
            ZIndex = 6;
            Pai = ToggleLabel;
        });

        local RelativeOffset = 0;

        for _, Elemento no próximo, Container:GetChildren() do
            se não for Element:IsA('UIListLayout') então
                RelativeOffset = RelativeOffset + Element.Size.Y.Offset;
            fim;
        fim;

        local PickerFrameOuter = Library:Create('Frame', {
            Nome = 'Cor';
            BackgroundColor3 = Color3.new(1, 1, 1);
            BordaCor3 = Cor3.new(0, 0, 0);
            Posição = UDim2.new(0, 4, 0, 20 + RelativeOffset + 1);
            Tamanho = UDim2.new(1, -13, 0, 253);
            Visível = falso;
            ZIndex = 15;
            Pai = Container.Parent;
        });

        local PickerFrameInner = Library:Create('Frame', {
            BackgroundColor3 = Biblioteca.BackgroundColor;
            BorderColor3 = Library.OutlineColor;
            BorderMode = Enum.BorderMode.Inset;
            Tamanho = UDim2.new(1, 0, 1, 0);
            ZIndex = 16;
            Pai = PickerFrameOuter;
        });

        local Highlight = Library:Create('Frame', {
            BackgroundColor3 = Biblioteca.AccentColor;
            BorderSizePixel = 0;
            Tamanho = UDim2.new(1, 0, 0, 2);
            ZIndex = 17;
            Pai = PickerFrameInner;
        });

        local SatVibMapOuter = Library:Create('Frame', {
            BordaCor3 = Cor3.new(0, 0, 0);
            Posição = UDim2.new(0, 4, 0, 25);
            Tamanho = UDim2.new(0, 200, 0, 200);
            ZIndex = 17;
            Pai = PickerFrameInner;
        });

        local SatVibMapInner = Library:Create('Frame', {
            BackgroundColor3 = Biblioteca.BackgroundColor;
            BorderColor3 = Library.OutlineColor;
            BorderMode = Enum.BorderMode.Inset;
            Tamanho = UDim2.new(1, 0, 1, 0);
            ZIndex = 18;
            Pai = SatVibMapOuter;
        });

        local SatVibMap = Library:Create('ImageLabel', {
            BorderSizePixel = 0;
            Tamanho = UDim2.new(1, 0, 1, 0);
            ZIndex = 18;
            Image = 'rbxassetid://4155801252';
            Pai = SatVibMapInner;
        });

        local HueSelectorOuter = Library:Create('Frame', {
            BordaCor3 = Cor3.new(0, 0, 0);
            Posição = UDim2.new(0, 208, 0, 25);
            Tamanho = UDim2.new(0, 15, 0, 200);
            ZIndex = 17;
            Pai = PickerFrameInner;
        });

        local HueSelectorInner = Library:Create('Frame', {
            BackgroundColor3 = Color3.new(1, 1, 1);
            BorderSizePixel = 0;
            Tamanho = UDim2.new(1, 0, 1, 0);
            ZIndex = 18;
            Pai = HueSelectorOuter;
        });

        local HueTextSize = Library:GetTextBounds('Hex color', Enum.Font.Code, 16) + 3
        local RgbTextSize = Library:GetTextBounds('255, 255, 255', Enum.Font.Code, 16) + 3

        local HueBoxOuter = Library:Create('Frame', {
            BordaCor3 = Cor3.new(0, 0, 0);
            Posição = UDim2.fromOffset(4, 228),
            Tamanho = UDim2.new(0.5, -6, 0, 20),
            ZIndex = 18,
            Pai = PickerFrameInner;
        });

        local HueBoxInner = Library:Create('Frame', {
            BackgroundColor3 = Biblioteca.MainColor;
            BorderColor3 = Library.OutlineColor;
            BorderMode = Enum.BorderMode.Inset;
            Tamanho = UDim2.new(1, 0, 1, 0);
            ZIndex = 18,
            Pai = HueBoxOuter;
        });

        Biblioteca:Create('UIGradient', {
            Cor = ColorSequence.new({
                ColorSequenceKeypoint.new(0, Color3.new(1, 1, 1)),
                ColorSequenceKeypoint.new(1, Color3.fromRGB(212, 212, 212))
            });
            Rotação = 90;
            Pai = HueBoxInner;
        });

        local HueBox = Library:Create('TextBox', {
            BackgroundTransparency = 1;
            Posição = UDim2.new(0, 5, 0, 0);
            Tamanho = UDim2.new(1, -5, 1, 0);
            Fonte = Enum.Font.Code;
            PlaceholderColor3 = Color3.fromRGB(190, 190, 190);
            PlaceholderText = 'Cor hexadecimal',
            Texto = '#FFFFFF',
            TextColor3 = Biblioteca.FontColor;
            TextSize = 14;
            TextStrokeTransparency = 0;
            TextXAlignment = Enum.TextXAlignment.Left;
            ZIndex = 20,
            Pai = HueBoxInner;
        });

        local RgbBoxBase = Library:Create(HueBoxOuter:Clone(), {
            Posição = UDim2.new(0.5, 2, 0, 228),
            Tamanho = UDim2.new(0.5, -6, 0, 20),
            Pai = PickerFrameInner
        })  

        local RgbBox = Library:Create(RgbBoxBase.Frame:FindFirstChild('TextBox'), {
            Texto = '255, 255, 255',
            PlaceholderText = 'Cor RGB',
            TextColor3 = Biblioteca.FontColor,
        })

        local DisplayLabel = Biblioteca:CreateLabel({
            Tamanho = UDim2.new(1, 0, 0, 14);
            Posição = UDim2.fromOffset(5, 5);
            TextXAlignment = Enum.TextXAlignment.Left;
            TextSize = 14;
            Text = ColorPicker.Title,--Info.Default;
            TextWrapped = false;
            ZIndex = 16;
            Pai = PickerFrameInner;
        });


        Library:AddToRegistry(PickerFrameInner, { BackgroundColor3 = 'BackgroundColor'; BorderColor3 = 'OutlineColor'; });
        Library:AddToRegistry(Highlight, { BackgroundColor3 = 'AccentColor'; });
        Library:AddToRegistry(SatVibMapInner, { BackgroundColor3 = 'BackgroundColor'; BorderColor3 = 'OutlineColor'; });

        Library:AddToRegistry(HueBoxInner, { BackgroundColor3 = 'MainColor'; BorderColor3 = 'OutlineColor'; });
        Library:AddToRegistry(RgbBoxBase.Frame, { BackgroundColor3 = 'MainColor'; BorderColor3 = 'OutlineColor'; });
        Library:AddToRegistry(RgbBox, { TextColor3 = 'FontColor', });
        Library:AddToRegistry(HueBox, { TextColor3 = 'FontColor', });

        local SequenceTable = {};

        para matiz = 0, 1, 0,1 faça
            table.insert(SequenceTable, ColorSequenceKeypoint.new(Hue, Color3.fromHSV(Hue, 1, 1)));
        fim;

        local HueSelectorGradient = Library:Create('UIGradient', {
            Color = ColorSequence.new(SequenceTable);
            Rotação = 90;
            Pai = HueSelectorInner;
        });
        
        HueBox.FocusLost:Connect(função(enter)
            se entrar então
                sucesso local, resultado = pcall(Color3.fromHex, HueBox.Text)
                se sucesso e typeof(resultado) == 'Color3' então
                    ColorPicker.Hue, ColorPicker.Sat, ColorPicker.Vib = Color3.toHSV(resultado)
                fim
            fim

            Seletor de Cores:Display()
        fim)

        RgbBox.FocusLost:Connect(função(enter)
            se entrar então
                local r, g, b = RgbBox.Text:match('(%d+),%s*(%d+),%s*(%d+)')
                se r e g e b então
                    ColorPicker.Hue, ColorPicker.Sat, ColorPicker.Vib = Color3.toHSV(Color3.fromRGB(r, g, b))
                fim
            fim

            Seletor de Cores:Display()
        fim)

        função ColorPicker:Display()
            ColorPicker.Value = Color3.fromHSV(ColorPicker.Hue, ColorPicker.Sat, ColorPicker.Vib);
            SatVibMap.BackgroundColor3 = Color3.fromHSV(ColorPicker.Hue, 1, 1);

            Biblioteca:Create(DisplayFrame, {
                BackgroundColor3 = ColorPicker.Value;
                BorderColor3 = Biblioteca:GetDarkerColor(ColorPicker.Value);
            });

            HueBox.Text = '#' .. ColorPicker.Value:ToHex()
            RgbBox.Text = table.concat({ math.floor(ColorPicker.Value.R * 255), math.floor(ColorPicker.Value.G * 255), math.floor(ColorPicker.Value.B * 255) }, ' , ')

            se ColorPicker.Changed então
                ColorPicker.Changed();
            fim;
        fim;

        função ColorPicker:OnChanged(Func)
            ColorPicker.Changed = Função;
            Função();
        fim;

        função ColorPicker:Mostrar()
            for Frame, Val in next, Library.OpenedFrames do
                se Frame.Name == 'Cor' então
                    Frame.Visible = false;
                    Library.OpenedFrames[Frame] = nil;
                fim;
            fim;

            PickerFrameOuter.Visible = verdadeiro;
            Library.OpenedFrames[PickerFrameOuter] = verdadeiro;
        fim;

        função ColorPicker:Ocultar()
            PickerFrameOuter.Visible = false;
            Library.OpenedFrames[PickerFrameOuter] = nil;
        fim;

        função ColorPicker:SetValue(HSV)
            local Color = Color3.fromHSV(HSV[1], HSV[2], HSV[3]);

            ColorPicker:SetHSVFromRGB(Color);
            ColorSeletor:Display();
        fim;

        função ColorPicker:SetValueRGB(Color)
            ColorPicker:SetHSVFromRGB(Color);
            ColorSeletor:Display();
        fim;

        SatVibMap.InputBegan:Connect(function(Input)
            se Input.UserInputType == Enum.UserInputType.MouseButton1 então
                while InputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1) faça
                    local MinX = SatVibMap.AbsolutePosition.X;
                    local MaxX = MinX + SatVibMap.AbsoluteSize.X;
                    local MouseX = math.clamp(Mouse.X, MinX, MaxX);

                    local MinY = SatVibMap.AbsolutePosition.Y;
                    local MaxY = MinY + SatVibMap.AbsoluteSize.Y;
                    local MouseY = math.clamp(Mouse.Y, MinY, MaxY);

                    ColorPicker.Sat = (MouseX - MinX) / (MaxX - MinX);
                    ColorPicker.Vib = 1 - ((MouseY - MinY) / (MaxY - MinY));
                    ColorSeletor:Display();

                    RenderStepped:Wait();
                fim;

                Biblioteca:AttemptSave();
            fim;
        fim);

        HueSelectorInner.InputBegan:Connect(function(Input)
            se Input.UserInputType == Enum.UserInputType.MouseButton1 então
                while InputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1) faça
                    local MinY = HueSelectorInner.AbsolutePosition.Y;
                    local MaxY = MinY + HueSelectorInner.AbsoluteSize.Y;
                    local MouseY = math.clamp(Mouse.Y, MinY, MaxY);

                    ColorPicker.Hue = ((MouseY - MinY) / (MaxY - MinY));
                    ColorSeletor:Display();

                    RenderStepped:Wait();
                fim;

                Biblioteca:AttemptSave();
            fim;
        fim);

        DisplayFrame.InputBegan:Connect(function(Input)
            se Input.UserInputType == Enum.UserInputType.MouseButton1 e não Library:MouseIsOverOpenedFrame() então
                se PickerFrameOuter.Visible então
                    ColorSeletor:Ocultar();
                senão
                    ColorSeletor:Mostrar();
                fim;
            fim;
        fim);

        Biblioteca:GiveSignal(InputService.InputBegan:Connect(function(Input)
            se Input.UserInputType == Enum.UserInputType.MouseButton1 então
                local AbsPos, AbsSize = PickerFrameOuter.AbsolutePosition, PickerFrameOuter.AbsoluteSize;

                se Mouse.X < AbsPos.X ou Mouse.X > AbsPos.X + AbsSize.X
                    ou Mouse.Y < (AbsPos.Y - 20 - 1) ou Mouse.Y > AbsPos.Y + AbsSize.Y então

                    ColorSeletor:Ocultar();
                fim;
            fim;
        fim))

        ColorSeletor:Display();

        Opções[Idx] = ColorSeletor;

        retornar auto;
    fim;

    função Funcs:AddKeyPicker(Idx, Info)
        local ParentObj = self;
        local ToggleLabel = self.TextLabel;
        local Container = self.Container;

        seletor de chaves local = {
            Valor = Info.Padrão;
            Alternado = falso;
            Modo = Info.Mode ou 'Alternar'; -- Sempre, Alternar, Segure
            Tipo = 'KeySelecionador';

            SyncToggleState = Info.SyncToggleState ou false;
        };

        se KeyPicker.SyncToggleState então
            Info.Modes = { 'Alternar' }
            Info.Mode = 'Alternar'
        fim

        local RelativeOffset = 0;

        for _, Elemento no próximo, Container:GetChildren() do
            se não for Element:IsA('UIListLayout') então
                RelativeOffset = RelativeOffset + Element.Size.Y.Offset;
            fim;
        fim;

        local PickOuter = Library:Create('Frame', {
            BordaCor3 = Cor3.new(0, 0, 0);
            Tamanho = UDim2.new(0, 28, 0, 15);
            ZIndex = 6;
            Pai = ToggleLabel;
        });

        local PickInner = Library:Create('Frame', {
            BackgroundColor3 = Biblioteca.BackgroundColor;
            BorderColor3 = Library.OutlineColor;
            BorderMode = Enum.BorderMode.Inset;
            Tamanho = UDim2.new(1, 0, 1, 0);
            ZIndex = 7;
            Pai = PickOuter;
        });

        Biblioteca:AddToRegistry(PickInner, {
            BackgroundColor3 = 'BackgroundColor';
            BorderColor3 = 'Cor do Contorno';
        });

        local DisplayLabel = Biblioteca:CreateLabel({
            Tamanho = UDim2.new(1, 0, 1, 0);
            TextSize = 13;
            Text = Info.Padrão;
            TextWrapped = verdadeiro;
            ZIndex = 8;
            Pai = PickInner;
        });

        local ModeSelectOuter = Library:Create('Frame', {
            BordaCor3 = Cor3.new(0, 0, 0);
            Posição = UDim2.new(1, 0, 0, RelativeOffset + 1);
            Tamanho = UDim2.new(0, 60, 0, 45 + 2);
            Visível = falso;
            ZIndex = 14;
            Pai = Container.Parent;
        });

        local ModeSelectInner = Library:Create('Frame', {
            BackgroundColor3 = Biblioteca.BackgroundColor;
            BorderColor3 = Library.OutlineColor;
            BorderMode = Enum.BorderMode.Inset;
            Tamanho = UDim2.new(1, 0, 1, 0);
            ZIndex = 15;
            Pai = ModeSelectOuter;
        });

        Biblioteca:AddToRegistry(ModeSelectInner, {
            BackgroundColor3 = 'BackgroundColor';
            BorderColor3 = 'Cor do Contorno';
        });

        Biblioteca:Create('UIListLayout', {
            FillDirection = Enum.FillDirection.Vertical;
            SortOrder = Enum.SortOrder.LayoutOrder;
            Pai = ModeSelectInner;
        });

        local ContainerLabel = Biblioteca:CreateLabel({
            TextXAlignment = Enum.TextXAlignment.Left;
            Tamanho = UDim2.new(1, 0, 0, 18);
            TextSize = 13;
            Visível = falso;
            ZIndex = 110;
            Pai = Library.KeybindContainer;
        }, verdadeiro);

        modos locais = Info.Modes ou { 'Sempre', 'Alternar', 'Manter' };
        botões de modo locais = {};

        para Idx, Mode in next, Modes do
            botão de modo local = {};

            local Label = Biblioteca:CreateLabel({
                Tamanho = UDim2.new(1, 0, 0, 15);
                TextSize = 13;
                Texto = Modo;
                ZIndex = 16;
                Pai = ModeSelectInner;
            });

            função ModeButton:Select()
                for _, Button in next, ModeButtons do
                    Botão:Desmarcar();
                fim;

                KeyPicker.Mode = Modo;

                Label.TextColor3 = Biblioteca.AccentColor;
                Library.RegistryMap[Label].Properties.TextColor3 = 'AccentColor';

                ModeSelectOuter.Visible = false;
            fim;

            função ModeButton: Desmarcar ()
                KeyPicker.Mode = nil;

                Label.TextColor3 = Biblioteca.FontColor;
                Library.RegistryMap[Label].Properties.TextColor3 = 'FontColor';
            fim;

            Label.InputBegan:Connect(function(Input)
                se Input.UserInputType == Enum.UserInputType.MouseButton1 então
                    Botão Modo:Selecionar();
                    Biblioteca:AttemptSave();
                fim;
            fim);

            se Modo == KeyPicker.Mode então
                Botão Modo:Selecionar();
            fim;

            ModeButtons[Modo] = ModeButton;
        fim;

        função KeySeletor:Atualizar()
            se Info.NoUI então
                Retorna;
            fim;

            estado local = KeyPicker:GetState();

            ContainerLabel.Text = string.format('[%s] %s (%s)', KeyPicker.Value, Info.Text, KeyPicker.Mode);

            ContainerLabel.Visible = verdadeiro;
            ContainerLabel.TextColor3 = Estado e Library.AccentColor ou Library.FontColor;

            Library.RegistryMap[ContainerLabel].Properties.TextColor3 = Estado e 'AccentColor' ou 'FontColor';

            local YSize = 0
            tamanho X local = 0
            
            for _, Label in next, Library.KeybindContainer:GetChildren() faça
                se Label:IsA('TextLabel') e Label.Visible então
                    Tamanho Y = Tamanho Y + 18;
                    se (Label.TextBounds.X > XSize) então
                        XSize = Label.TextBounds.X
                    fim
                fim;
            fim;

            Library.KeybindFrame.Size = UDim2.new(0, math.max(XSize + 10, 210), 0, YSize + 23)
        fim;

        função KeyPicker:GetState()
            se KeyPicker.Mode == 'Sempre' então
                retornar verdadeiro;
            elseif KeyPicker.Mode == 'Hold' então
                chave local = KeyPicker.Value;

                se Chave == 'MB1' ou Chave == 'MB2' então
                    chave de retorno == 'MB1' e InputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1)
                        ou Chave == 'MB2' e InputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton2);
                senão
                    return InputService:IsKeyDown(Enum.KeyCode[KeyPicker.Value]);
                fim;
            senão
                return KeyPicker.Toggled;
            fim;
        fim;

        função KeyPicker:SetValue(Data)
            Chave local, Modo = Dados[1], Dados[2];
            DisplayLabel.Text = Chave;
            KeyPicker.Value = Chave;
            Botões de Modo[Modo]:Selecionar();
            KeySeletor:Atualizar();
        fim;

        função KeyPicker:OnClick(Callback)
            KeyPicker.Clicked = retorno de chamada
        fim


        se ParentObj.Addons então
            table.insert(ParentObj.Addons, KeyPicker)
        fim

        função KeyPicker:DoClick ()
            se ParentObj.Type == 'Toggle' e KeyPicker.SyncToggleState então
                ParentObj:SetValue(não ParentObj.Value)
            fim

            se KeyPicker.Cliquei então
                KeyPicker.Clicked()
            fim
        fim

        Seleção local = false;

        PickOuter.InputBegan:Connect(function(Input)
            se Input.UserInputType == Enum.UserInputType.MouseButton1 e não Library:MouseIsOverOpenedFrame() então
                Escolhendo = verdadeiro;

                DisplayLabel.Text = '';

                Ruptura local;
                local Texto = '';

                tarefa.spawn(função()
                    enquanto (não quebra) faça
                        se Texto == '...' então
                            Texto = '';
                        fim;

                        Texto = Texto .. '.';
                        DisplayLabel.Text = Texto;

                        espera(0.4);
                    fim;
                fim);

                espera(0.2);

                Evento local;
                Evento = InputService.InputBegan:Connect(function(Input)
                    chave local;

                    se Input.UserInputType == Enum.UserInputType.Keyboard então
                        Chave = Input.KeyCode.Name;
                    elseif Input.UserInputType == Enum.UserInputType.MouseButton1 então
                        Chave = 'MB1';
                    elseif Input.UserInputType == Enum.UserInputType.MouseButton2 então
                        Chave = 'MB2';
                    fim;

                    Quebra = verdadeiro;
                    Escolher = falso;

                    DisplayLabel.Text = Chave;
                    KeyPicker.Value = Chave;

                    Biblioteca:AttemptSave();

                    Evento:Desconectar();
                fim);
            elseif Input.UserInputType == Enum.UserInputType.MouseButton2 e não Library:MouseIsOverOpenedFrame() então
                ModeSelectOuter.Visible = verdadeiro;
            fim;
        fim);

        Biblioteca:GiveSignal(InputService.InputBegan:Connect(function(Input)
            se (não Picking) então
                se KeyPicker.Mode == 'Alternar' então
                    chave local = KeyPicker.Value;

                    se Chave == 'MB1' ou Chave == 'MB2' então
                        if Key == 'MB1' e Input.UserInputType == Enum.UserInputType.MouseButton1
                        ou Chave == 'MB2' e Input.UserInputType == Enum.UserInputType.MouseButton2 então
                            KeyPicker.Toggled = não KeyPicker.Toggled
                            Key Picker: DoClick ()
                        fim;
                    elseif Input.UserInputType == Enum.UserInputType.Keyboard então
                        se Input.KeyCode.Name == Chave então
                            KeyPicker.Toggled = não KeyPicker.Toggled;
                            Key Picker: DoClick ()
                        fim;
                    fim;
                fim;

                KeySeletor:Atualizar();
            fim;

            se Input.UserInputType == Enum.UserInputType.MouseButton1 então
                local AbsPos, AbsSize = ModeSelectOuter.AbsolutePosition, ModeSelectOuter.AbsoluteSize;

                se Mouse.X < AbsPos.X ou Mouse.X > AbsPos.X + AbsSize.X
                    ou Mouse.Y < (AbsPos.Y - 20 - 1) ou Mouse.Y > AbsPos.Y + AbsSize.Y então

                    ModeSelectOuter.Visible = false;
                fim;
            fim;
        fim))

        Biblioteca:GiveSignal(InputService.InputEnded:Connect(function(Input)
            se (não Picking) então
                KeySeletor:Atualizar();
            fim;
        fim))

        KeySeletor:Atualizar();

        Opções[Idx] = KeySeletor;

        retornar auto;
    fim;

    BaseAddons.__index = Funções;
    BaseAddons.__namecall = function(Tabela, Chave, ...)
        return Funcs[Chave](...);
    fim;
fim;

local BaseGroupbox = {};

Faz
    funções locais = {};

    função Funcs:AddBlank(Size)
        caixa de grupo local = self;
        local Container = Groupbox.Container;

        Biblioteca:Create('Frame', {
            BackgroundTransparency = 1;
            Tamanho = UDim2.new(1, 0, 0, Tamanho);
            ZIndex = 1;
            Pai = Contêiner;
        });
    fim;

    função Funcs:AddLabel(Text, DoesWrap)
        rótulo local = {};

        caixa de grupo local = self;
        local Container = Groupbox.Container;

        local TextLabel = Biblioteca:CreateLabel({
            Tamanho = UDim2.new(1, -4, 0, 15);
            TextSize = 14;
            Texto = Texto;
            TextWrapped = DoesWrap ou false,
            RichText = verdadeiro,
            TextXAlignment = Enum.TextXAlignment.Left;
            ZIndex = 5;
            Pai = Contêiner;
        });

        se fazWrap então
            local Y = select(2, Library:GetTextBounds(Text, Enum.Font.Code, 14, Vector2.new(TextLabel.AbsoluteSize.X, math.huge)))
            TextLabel.Size = UDim2.new(1, -4, 0, Y)
        senão
            Biblioteca:Create('UIListLayout', {
                Preenchimento = UDim.new(0, 4);
                FillDirection = Enum.FillDirection.Horizontal;
                HorizontalAlignment = Enum.HorizontalAlignment.Right;
                SortOrder = Enum.SortOrder.LayoutOrder;
                Pai = TextLabel;
            });
        fim

        Label.TextLabel = TextLabel;
        Label.Container = Contêiner;

        Rótulo da função:SetText(Texto)
            TextLabel.Text = Texto

            se fazWrap então
                local Y = select(2, Library:GetTextBounds(Text, Enum.Font.Code, 14, Vector2.new(TextLabel.AbsoluteSize.X, math.huge)))
                TextLabel.Size = UDim2.new(1, -4, 0, Y)
            fim

            Caixa de Grupo:Redimensionar();
        fim

        if (não DoesWrap) então
            setmetatable(Label, BaseAddons);
        fim

        Caixa de grupo:AdicionarBlank(5);
        Caixa de Grupo:Redimensionar();

        etiqueta de devolução;
    fim;

    função Funcs:AddButton(Text, Func)
        botão local = {};

        caixa de grupo local = self;
        local Container = Groupbox.Container;

        local ButtonOuter = Library:Create('Frame', {
            BordaCor3 = Cor3.new(0, 0, 0);
            Tamanho = UDim2.new(1, -4, 0, 20);
            ZIndex = 5;
            Pai = Contêiner;
        });

        Biblioteca:AddToRegistry(ButtonOuter, {
            BorderColor3 = 'Preto';
        });

        local ButtonInner = Library:Create('Frame', {
            BackgroundColor3 = Biblioteca.MainColor;
            BorderColor3 = Library.OutlineColor;
            BorderMode = Enum.BorderMode.Inset;
            Tamanho = UDim2.new(1, 0, 1, 0);
            ZIndex = 6;
            Pai = ButtonOuter;
        });

        Biblioteca:AddToRegistry(ButtonInner, {
            BackgroundColor3 = 'MainColor';
            BorderColor3 = 'Cor do Contorno';
        });

        Biblioteca:Create('UIGradient', {
            Cor = ColorSequence.new({
                ColorSequenceKeypoint.new(0, Color3.new(1, 1, 1)),
                ColorSequenceKeypoint.new(1, Color3.fromRGB(212, 212, 212))
            });
            Rotação = 90;
            Pai = ButtonInner;
        });

        local ButtonLabel = Biblioteca:CreateLabel({
            Tamanho = UDim2.new(1, 0, 1, 0);
            TextSize = 14;
            Texto = Texto;
            ZIndex = 6;
            Pai = ButtonInner;
        });

        Biblioteca:OnHighlight(ButtonOuter, ButtonOuter,
            { BorderColor3 = 'AccentColor' },
            { BorderColor3 = 'Preto' }
        );

        ButtonOuter.InputBegan:Connect(function(Input)
            se Input.UserInputType == Enum.UserInputType.MouseButton1 e não Library:MouseIsOverOpenedFrame() então
                Função();
            fim;
        fim);

        botão de função: Adicionar dica de ferramenta (dica)
            if type(tip) == 'string' então
                Biblioteca: AddToolTip(tip, ButtonOuter)
            fim
            Botão de retorno
        fim

        botão de função: AddButton (Text, Func)
            SubBotão local = {}

            ButtonOuter.Size = UDim2.new(0.5, -2, 0, 20)
            
            local Outer = ButtonOuter:Clone()
            local Inner = Outer.Frame;
            local Label = Inner:FindFirstChildWhichIsA('TextLabel')

            Outer.Position = UDim2.new(1, 2, 0, 0)
            Outer.Size = UDim2.fromOffset(ButtonOuter.AbsoluteSize.X - 2, ButtonOuter.AbsoluteSize.Y)
            Outer.Parent = ButtonOuter

            Label.Texto = Texto;

            Biblioteca:AddToRegistry(Inner, {
                BackgroundColor3 = 'MainColor';
                BorderColor3 = 'Cor do Contorno';
            });
    
            Biblioteca:OnHighlight(Outer, Outer,
                { BorderColor3 = 'AccentColor' },
                { BorderColor3 = 'Preto' }
            )

            Biblioteca:Create('UIGradient', {
                Cor = ColorSequence.new({
                    ColorSequenceKeypoint.new(0, Color3.new(1, 1, 1)),
                    ColorSequenceKeypoint.new(1, Color3.fromRGB(212, 212, 212))
                });

                Rotação = 90;
                Pai = Interno;
            });

            Outer.InputBegan:Connect(function(Input)
                se Input.UserInputType == Enum.UserInputType.MouseButton1 e não Library:MouseIsOverOpenedFrame() então
                    Função();
                fim;
            fim);

            função SubButton:Adicionar dica de ferramenta (dica)
                if type(tip) == 'string' então
                    Biblioteca: AddToolTip(tip, Outer)
                fim
                retornar SubButton
            fim

            retornar SubButton
        fim

        Caixa de grupo:AdicionarBlank(5);
        Caixa de Grupo:Redimensionar();

        Botão de retorno;
    fim;

    funções da função:AddDivider()
        caixa de grupo local = self;
        local Container = self.Container

        divisor local = {
            Tipo = 'Divisor',
        }

        Groupbox:AdicionarBlank(2);
        local DividerOuter = Library:Create('Frame', {
            BordaCor3 = Cor3.new(0, 0, 0);
            Tamanho = UDim2.new(1, -4, 0, 5);
            ZIndex = 5;
            Pai = Contêiner;
        });

        local DividerInner = Library:Create('Frame', {
            BackgroundColor3 = Biblioteca.MainColor;
            BorderColor3 = Library.OutlineColor;
            BorderMode = Enum.BorderMode.Inset;
            Tamanho = UDim2.new(1, 0, 1, 0);
            ZIndex = 6;
            Pai = DivisorOuter;
        });

        Biblioteca:AddToRegistry(DividerOuter, {
            BorderColor3 = 'Preto';
        });

        Biblioteca:AddToRegistry(DividerInner, {
            BackgroundColor3 = 'MainColor';
            BorderColor3 = 'Cor do Contorno';
        });

        Caixa de grupo:AdicionarBlank(9);
        Caixa de Grupo:Redimensionar();
    fim

    função Funcs:AddInput(Idx, Info)
        caixa de texto local = {
            Valor = Info.Padrão ou '';
            Numérico = Info.Numeric ou false;
            Concluído = Info.Concluído ou falso;
            Tipo = 'Entrada';
        };

        caixa de grupo local = self;
        local Container = Groupbox.Container;

        local InputLabel = Biblioteca:CreateLabel({
            Tamanho = UDim2.new(1, 0, 0, 15);
            TextSize = 14;
            Text = Info.Text;
            TextXAlignment = Enum.TextXAlignment.Left;
            ZIndex = 5;
            Pai = Contêiner;
        });

        Groupbox:AdicionarBlank(1);

        local TextBoxOuter = Library:Create('Frame', {
            BordaCor3 = Cor3.new(0, 0, 0);
            Tamanho = UDim2.new(1, -4, 0, 20);
            ZIndex = 5;
            Pai = Contêiner;
        });

        local TextBoxInner = Library:Create('Frame', {
            BackgroundColor3 = Biblioteca.MainColor;
            BorderColor3 = Library.OutlineColor;
            BorderMode = Enum.BorderMode.Inset;
            Tamanho = UDim2.new(1, 0, 1, 0);
            ZIndex = 6;
            Pai = TextBoxOuter;
        });

        Biblioteca:AddToRegistry(TextBoxInner, {
            BackgroundColor3 = 'MainColor';
            BorderColor3 = 'Cor do Contorno';
        });

        Biblioteca:OnHighlight(TextBoxOuter, TextBoxOuter,
            { BorderColor3 = 'AccentColor' },
            { BorderColor3 = 'Preto' }
        );

        if type(Info.Tooltip) == 'string' então
            Biblioteca:AddToolTip(Info.Tooltip, TextBoxOuter)
        fim

        Biblioteca:Create('UIGradient', {
            Cor = ColorSequence.new({
                ColorSequenceKeypoint.new(0, Color3.new(1, 1, 1)),
                ColorSequenceKeypoint.new(1, Color3.fromRGB(212, 212, 212))
            });
            Rotação = 90;
            Pai = TextBoxInner;
        });

        local Container = Library:Create('Frame', {
            BackgroundTransparency = 1;
            ClipesDescendentes = true;

            Posição = UDim2.new(0, 5, 0, 0);
            Tamanho = UDim2.new(1, -5, 1, 0);

            ZIndex = 7;
            Pai = TextBoxInner;
        })

        local Box = Library:Create('TextBox', {
            BackgroundTransparency = 1;

            Posição = UDim2.fromOffset(0, 0),
            Tamanho = UDim2.fromScale(5, 1),
            
            Fonte = Enum.Font.Code;
            PlaceholderColor3 = Color3.fromRGB(190, 190, 190);
            PlaceholderText = Info.Placeholder ou '';

            Text = Info.Padrão ou '';
            TextColor3 = Biblioteca.FontColor;
            TextSize = 14;
            TextStrokeTransparency = 0;
            TextXAlignment = Enum.TextXAlignment.Left;

            ZIndex = 7;
            Pai = Contêiner;
        });
        
        função Textbox:SetValue(Text)
            se Info.MaxLength e #Text > Info.MaxLength então
                Text = Text:sub(1, Info.MaxLength);
            fim;

            se Textbox.Numeric então
                if (não tonumber(Text)) e Text:len() > 0 então
                    Text = Textbox.Value
                fim
            fim

            Textbox.Value = Texto;
            Caixa.Texto = Texto;
                
            se Textbox.Alterado então
                Textbox.Changed();
            fim;
        fim;

        se Textbox.Finished então
            Box.FocusLost:Connect(function(enter)
                se não entrar então retorne fim
                
                Textbox:SetValue(Box.Text);
                Biblioteca:AttemptSave();
            fim)
        senão
            Box:GetPropertyChangedSignal('Text'):Connect(function()
                Textbox:SetValue(Box.Text);
                Biblioteca:AttemptSave();
            fim);
        fim

        -- https://devforum.roblox.com/t/how-to-make-textboxes-follow-current-cursor-position/1368429/6
        -- obrigado nicemike40 :)

        função local Atualizar()
            PADDING local = 5
            revelação local = Container.AbsoluteSize.X

            se não Box:IsFocused() ou Box.TextBounds.X <= revelar - 2 * PADDING então
                -- não estamos focados, ou nos encaixamos, então seja normal
                Box.Position = UDim2.new(0, PADDING, 0, 0)
            senão
                -- estamos focados e não nos encaixamos, então ajuste a posição
                cursor local = Box.CursorPosition
                se cursor ~= -1 então
                    -- calcula a largura em pixels do texto do início ao cursor
                    subtexto local = string.sub(Box.Text, 1, cursor-1)
                    largura local = TextService:GetTextSize(subtexto, Box.TextSize, Box.Font, Vector2.new(math.huge, math.huge)).X
                    
                    -- verifica se estamos dentro da caixa com o cursor
                    local currentCursorPos = Box.Position.X.Offset + largura

                    -- ajuste se necessário
                    se currentCursorPos < PADDING então
                        Box.Position = UDim2.fromOffset(PADDING-width, 0)
                    elseif currentCursorPos > revelar - PADDING - 1 então
                        Box.Position = UDim2.fromOffset(reveal-width-PADDING-1, 0)
                    fim
                fim
            fim
        fim

        task.spawn(Atualizar)

        Box:GetPropertyChangedSignal('Text'):Connect(Update)
        Box:GetPropertyChangedSignal('CursorPosition'):Connect(Update)
        Box.FocusLost:Connect(Update)
        Box.Focused:Connect(Update)

        Biblioteca:AddToRegistry(Caixa, {
            TextColor3 = 'FontColor';
        });

        função Textbox:OnChanged(Func)
            Textbox.Changed = Função;
            Função();
        fim;

        Caixa de grupo:AdicionarBlank(5);
        Caixa de Grupo:Redimensionar();

        Opções[Idx] = Caixa de texto;

        retornar caixa de texto;
    fim;

    função Funcs:AddToggle(Idx, Info)
        Local Alternar = {
            Value = Info.Default ou false;
            Tipo = 'Alternar';

            Complementos = {},
        };

        caixa de grupo local = self;
        local Container = Groupbox.Container;

        local ToggleOuter = Library:Create('Frame', {
            BordaCor3 = Cor3.new(0, 0, 0);
            Tamanho = UDim2.new(0, 13, 0, 13);
            ZIndex = 5;
            Pai = Contêiner;
        });

        Biblioteca:AddToRegistry(ToggleOuter, {
            BorderColor3 = 'Preto';
        });

        local ToggleInner = Library:Create('Frame', {
            BackgroundColor3 = Biblioteca.MainColor;
            BorderColor3 = Library.OutlineColor;
            BorderMode = Enum.BorderMode.Inset;
            Tamanho = UDim2.new(1, 0, 1, 0);
            ZIndex = 6;
            Pai = ToggleOuter;
        });

        Biblioteca:AddToRegistry(ToggleInner, {
            BackgroundColor3 = 'MainColor';
            BorderColor3 = 'Cor do Contorno';
        });

        local ToggleLabel = Biblioteca:CreateLabel({
            Tamanho = UDim2.new(0, 216, 1, 0);
            Posição = UDim2.new(1, 6, 0, 0);
            TextSize = 14;
            Text = Info.Text;
            TextXAlignment = Enum.TextXAlignment.Left;
            ZIndex = 6;
            Pai = ToggleInner;
        });

        Biblioteca:Create('UIListLayout', {
            Preenchimento = UDim.new(0, 4);
            FillDirection = Enum.FillDirection.Horizontal;
            HorizontalAlignment = Enum.HorizontalAlignment.Right;
            SortOrder = Enum.SortOrder.LayoutOrder;
            Pai = ToggleLabel;
        });

        local ToggleRegion = Library:Create('Frame', {
            BackgroundTransparency = 1;
            Tamanho = UDim2.new(0, 170, 1, 0);
            ZIndex = 8;
            Pai = ToggleOuter;
        });

        Biblioteca:OnHighlight(ToggleRegion, ToggleOuter,
            { BorderColor3 = 'AccentColor' },
            { BorderColor3 = 'Preto' }
        );

        função Toggle:UpdateColors()
            Alternar:Exibir();
        fim;

        if type(Info.Tooltip) == 'string' então
            Biblioteca:AddToolTip(Info.Tooltip, ToggleRegion)
        fim

        função Alternar: Exibir ()
            ToggleInner.BackgroundColor3 = Toggle.Value e Library.AccentColor ou Library.MainColor;
            ToggleInner.BorderColor3 = Toggle.Value e Library.AccentColorDark ou Library.OutlineColor;

            Library.RegistryMap[ToggleInner].Properties.BackgroundColor3 = Toggle.Value e 'AccentColor' ou 'MainColor';
            Library.RegistryMap[ToggleInner].Properties.BorderColor3 = Toggle.Value e 'AccentColorDark' ou 'OutlineColor';
        fim;

        função Toggle:OnChanged(Func)
            Toggle.Changed = Função;
            Função();
        fim;

        função Toggle:SetValue(Bool)
            Bool = (não não Bool);

            Toggle.Value = Bool;
            Alternar:Exibir();

            para _, Addon em seguida, Toggle.Addons do
                se Addon.Type == 'KeyPicker' e Addon.SyncToggleState então
                    Addon.Toggled = Bool
                    Complemento: Atualizar ()
                fim
            fim

            se Toggle.Changed então
                Toggle.Changed();
            fim;
        fim;

        ToggleRegion.InputBegan:Connect(function(Input)
            se Input.UserInputType == Enum.UserInputType.MouseButton1 e não Library:MouseIsOverOpenedFrame() então
                Toggle:SetValue(not Toggle.Value) -- Por que não foi assim desde o início?
                Biblioteca:AttemptSave();
            fim;
        fim);

        Alternar:Exibir();
        Groupbox:AddBlank(Info.BlankSize or 5 + 2);
        Caixa de Grupo:Redimensionar();

        Toggle.TextLabel = ToggleLabel;
        Toggle.Container = Contêiner;
        setmetatable(Alternar, BaseAddons);

        Alterna[Idx] = Alterna;

        retornar Alternar;
    fim;

    função Funcs:AddSlider(Idx, Info)
        assert(Info.Default e Info.Text e Info.Min e Info.Max e Info.Rounding, 'Bad Slider Data');

        controle deslizante local = {
            Valor = Info.Padrão;
            Min = Info.Min;
            Max = Info.Max;
            Arredondamento = Info.Arredondamento;
            MaxSize = 232;
            Tipo = 'Slider';
        };

        caixa de grupo local = self;
        local Container = Groupbox.Container;

        se não Info.Compact então
            Biblioteca:CreateLabel({
                Tamanho = UDim2.new(1, 0, 0, 10);
                TextSize = 14;
                Text = Info.Text;
                TextXAlignment = Enum.TextXAlignment.Left;
                TextYAlignment = Enum.TextYAlignment.Bottom;
                ZIndex = 5;
                Pai = Contêiner;
            });

            Caixa de Grupo:AdicionarEm Branco(3);
        fim

        local SliderOuter = Library:Create('Frame', {
            BordaCor3 = Cor3.new(0, 0, 0);
            Tamanho = UDim2.new(1, -4, 0, 13);
            ZIndex = 5;
            Pai = Contêiner;
        });

        Biblioteca:AddToRegistry(SliderOuter, {
            BorderColor3 = 'Preto';
        });

        local SliderInner = Library:Create('Frame', {
            BackgroundColor3 = Biblioteca.MainColor;
            BorderColor3 = Library.OutlineColor;
            BorderMode = Enum.BorderMode.Inset;
            Tamanho = UDim2.new(1, 0, 1, 0);
            ZIndex = 6;
            Pai = SliderOuter;
        });

        Biblioteca:AddToRegistry(SliderInner, {
            BackgroundColor3 = 'MainColor';
            BorderColor3 = 'Cor do Contorno';
        });

        local Fill = Library:Create('Frame', {
            BackgroundColor3 = Biblioteca.AccentColor;
            BorderColor3 = Biblioteca.AccentColorDark;
            Tamanho = UDim2.new(0, 0, 1, 0);
            ZIndex = 7;
            Pai = SliderInner;
        });

        Biblioteca:AddToRegistry(Fill, {
            BackgroundColor3 = 'AccentColor';
            BorderColor3 = 'AccentColorDark';
        });

        local HideBorderRight = Library:Create('Frame', {
            BackgroundColor3 = Biblioteca.AccentColor;
            BorderSizePixel = 0;
            Posição = UDim2.new(1, 0, 0, 0);
            Tamanho = UDim2.new(0, 1, 1, 0);
            ZIndex = 8;
            Pai = Preencher;
        });

        Biblioteca:AddToRegistry(HideBorderRight, {
            BackgroundColor3 = 'AccentColor';
        });

        local DisplayLabel = Biblioteca:CreateLabel({
            Tamanho = UDim2.new(1, 0, 1, 0);
            TextSize = 14;
            Texto = 'Infinito';
            ZIndex = 9;
            Pai = SliderInner;
        });

        Biblioteca:OnHighlight(SliderOuter, SliderOuter,
            { BorderColor3 = 'AccentColor' },
            { BorderColor3 = 'Preto' }
        );

        if type(Info.Tooltip) == 'string' então
            Biblioteca:AddToolTip(Info.Tooltip, SliderOuter)
        fim

        função Slider:UpdateColors()
            Fill.BackgroundColor3 = Biblioteca.AccentColor;
            Fill.BorderColor3 = Biblioteca.AccentColorDark;
        fim;

        Função Slider:Display()
            local Sufixo = Info.Sufixo ou '';
            DisplayLabel.Text = string.format('%s/%s', Slider.Value .. Sufixo, Slider.Max .. Sufixo);

            local X = math.ceil(Library:MapValue(Slider.Value, Slider.Min, Slider.Max, 0, Slider.MaxSize));
            Fill.Size = UDim2.new(0, X, 1, 0);

            HideBorderRight.Visible = não (X == Slider.MaxSize ou X == 0);
        fim;

        slider de função:OnChanged(Func)
            Slider.Changed = Função;
            Função();
        fim;

        função local Round(Valor)
            se Slider.Rounding == 0 então
                return math.floor(Valor);
            fim;

            local Str = Valor .. '';
            local Ponto = Str:find('%.');

            return Ponto e tonumber(Str:sub(1, Dot + Slider.Rounding)) ou Value;
        fim;

        função Slider:GetValueFromXOffset(X)
            return Round(Biblioteca:MapValue(X, 0, Slider.MaxSize, Slider.Min, Slider.Max));
        fim;

        função Slider:SetValue(Str)
            local Num = tonumber(Str);

            se (não Num) então
                Retorna;
            fim;

            Num = math.clamp(Num, Slider.Min, Slider.Max);

            Slider.Value = Num;
            Controle deslizante:Exibir();

            se Slider.Mudou então
                Slider.Changed();
            fim;
        fim;

        SliderInner.InputBegan:Connect(function(Input)
            se Input.UserInputType == Enum.UserInputType.MouseButton1 e não Library:MouseIsOverOpenedFrame() então
                mPos local = Mouse.X;
                gPos local = Fill.Size.X.Offset;
                local Diff = mPos - (Fill.AbsolutePosition.X + gPos);

                while InputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1) faça
                    local nMPos = Rato.X;
                    local nX = math.clamp(gPos + (nMPos - mPos) + Diff, 0, Slider.MaxSize);

                    local nValue = Slider:GetValueFromXOffset(nX);
                    local OldValue = Slider.Value;
                    Slider.Value = nValue;

                    Controle deslizante:Exibir();

                    se nValue ~= OldValue e Slider.Changed então
                        Slider.Changed();
                    fim;

                    RenderStepped:Wait();
                fim;

                Biblioteca:AttemptSave();
            fim;
        fim);

        Controle deslizante:Exibir();
        Groupbox:AddBlank(Info.BlankSize or 6);
        Caixa de Grupo:Redimensionar();

        Opções[Idx] = Controle deslizante;

        retornar controle deslizante;
    fim;

    função Funcs:AddDropdown(Idx, Info)
        assert(Info.Text e Info.Values, 'Dados suspensos inválidos');

        Lista suspensa local = {
            Valores = Info.Valores;
            Valor = Info.Multi e {};
            Multi = Info.Multi;
            Tipo = 'Menu suspenso';
        };

        caixa de grupo local = self;
        local Container = Groupbox.Container;

        local RelativeOffset = 0;

        local DropdownLabel = Biblioteca:CreateLabel({
            Tamanho = UDim2.new(1, 0, 0, 10);
            TextSize = 14;
            Text = Info.Text;
            TextXAlignment = Enum.TextXAlignment.Left;
            TextYAlignment = Enum.TextYAlignment.Bottom;
            ZIndex = 5;
            Pai = Contêiner;
        });

        Caixa de Grupo:AdicionarEm Branco(3);

        for _, Elemento no próximo, Container:GetChildren() do
            se não for Element:IsA('UIListLayout') então
                RelativeOffset = RelativeOffset + Element.Size.Y.Offset;
            fim;
        fim;

        local DropdownOuter = Library:Create('Frame', {
            BordaCor3 = Cor3.new(0, 0, 0);
            Tamanho = UDim2.new(1, -4, 0, 20);
            ZIndex = 5;
            Pai = Contêiner;
        });

        Biblioteca:AddToRegistry(DropdownOuter, {
            BorderColor3 = 'Preto';
        });

        local DropdownInner = Library:Create('Frame', {
            BackgroundColor3 = Biblioteca.MainColor;
            BorderColor3 = Library.OutlineColor;
            BorderMode = Enum.BorderMode.Inset;
            Tamanho = UDim2.new(1, 0, 1, 0);
            ZIndex = 6;
            Pai = DropdownOuter;
        });

        Biblioteca:AddToRegistry(DropdownInner, {
            BackgroundColor3 = 'MainColor';
            BorderColor3 = 'Cor do Contorno';
        });

        Biblioteca:Create('UIGradient', {
            Cor = ColorSequence.new({
                ColorSequenceKeypoint.new(0, Color3.new(1, 1, 1)),
                ColorSequenceKeypoint.new(1, Color3.fromRGB(212, 212, 212))
            });
            Rotação = 90;
            Pai = DropdownInner;
        });

        local DropdownArrow = Library:Create('ImageLabel', {
            AnchorPoint = Vector2.new(0, 0.5);
            BackgroundTransparency = 1;
            Posição = UDim2.new(1, -16, 0,5, 0);
            Tamanho = UDim2.new(0, 12, 0, 12);
            Image = 'http://www.roblox.com/asset/?id=6282522798';
            ZIndex = 7;
            Pai = DropdownInner;
        });

        local ItemList = Biblioteca:CreateLabel({
            Posição = UDim2.new(0, 5, 0, 0);
            Tamanho = UDim2.new(1, -5, 1, 0);
            TextSize = 14;
            Texto = '--';
            TextXAlignment = Enum.TextXAlignment.Left;
            TextWrapped = verdadeiro;
            ZIndex = 7;
            Pai = DropdownInner;
        });

        Biblioteca:OnHighlight(DropdownOuter, DropdownOuter,
            { BorderColor3 = 'AccentColor' },
            { BorderColor3 = 'Preto' }
        );

        if type(Info.Tooltip) == 'string' então
            Biblioteca:AddToolTip(Info.Tooltip, DropdownOuter)
        fim

        local MAX_DROPDOWN_ITEMS = 8;

        local ListOuter = Library:Create('Frame', {
            BordaCor3 = Cor3.new(0, 0, 0);
            Posição = UDim2.new(0, 4, 0, 20 + RelativeOffset + 1 + 20);
            Tamanho = UDim2.new(1, -8, 0, MAX_DROPDOWN_ITEMS * 20 + 2);
            ZIndex = 20;
            Visível = falso;
            Pai = Container.Parent;
        });

        local ListInner = Library:Create('Frame', {
            BackgroundColor3 = Biblioteca.MainColor;
            BorderColor3 = Library.OutlineColor;
            BorderMode = Enum.BorderMode.Inset;
            BorderSizePixel = 0;
            Tamanho = UDim2.new(1, 0, 1, 0);
            ZIndex = 21;
            Pai = ListaOuter;
        });

        Biblioteca:AddToRegistry(ListInner, {
            BackgroundColor3 = 'MainColor';
            BorderColor3 = 'Cor do Contorno';
        });

        local Scrolling = Library:Create('ScrollingFrame', {
            BackgroundTransparency = 1;
            CanvasSize = UDim2.new(0, 0, 0, 0);
            Tamanho = UDim2.new(1, 0, 1, 0);
            ZIndex = 21;
            Pai = ListInner;

            TopImage = 'rbxasset://textures/ui/Scroll/scroll-middle.png',
            BottomImage = 'rbxasset://textures/ui/Scroll/scroll-middle.png',

            ScrollBarThickness = 3,
            ScrollBarImageColor3 = Library.AccentColor,
        });

        Biblioteca:AddToRegistry(Scrolling, {
            ScrollBarImageColor3 = 'AccentColor'
        })

        Biblioteca:Create('UIListLayout', {
            Preenchimento = UDim.new(0, 0);
            FillDirection = Enum.FillDirection.Vertical;
            SortOrder = Enum.SortOrder.LayoutOrder;
            Pai = Rolagem;
        });

        Menu suspenso de função:Display()
            Valores locais = Dropdown.Values;
            Local Str = '';

            se Info.Multi então
                para Idx, Value in next, Values ​​do
                    se Dropdown.Valor[Valor] então
                        Str = Str .. Value .. ', ';
                    fim;
                fim;

                Str = Str:sub(1, #Str - 2);
            senão
                Str = Dropdown.Value ou '';
            fim;

            ItemList.Text = (Str == '' e '--' ou Str);
        fim;

        Função suspensa:GetActiveValues()
            se Info.Multi então
                T local = {};

                for Value, Bool in next, Dropdown.Value do
                    table.insert(T, Value);
                fim;

                retorno T;
            senão
                return Dropdown.Value e 1 ou 0;
            fim;
        fim;

        Menu suspenso de função:SetValues()
            Valores locais = Dropdown.Values;
            Botões locais = {};

            for _, Elemento no próximo, Scrolling:GetChildren() do
                se não for Element:IsA('UIListLayout') então
                    -- Library:RemoveFromRegistry(Element);
                    Elemento:Destruir();
                fim;
            fim;

            contagem local = 0;

            para Idx, Value in next, Values ​​do
                tabela local = {};

                Contagem = Contagem + 1;

                local Button = Library:Create('Frame', {
                    BackgroundColor3 = Biblioteca.MainColor;
                    BorderColor3 = Library.OutlineColor;
                    BorderMode = Enum.BorderMode.Middle;
                    Tamanho = UDim2.new(1, -1, 0, 20);
                    ZIndex = 23;
                    Ativo = verdadeiro,
                    Pai = Rolagem;
                });

                Biblioteca:AddToRegistry(Botão, {
                    BackgroundColor3 = 'MainColor';
                    BorderColor3 = 'Cor do Contorno';
                });

                local ButtonLabel = Biblioteca:CreateLabel({
                    Tamanho = UDim2.new(1, -6, 1, 0);
                    Posição = UDim2.new(0, 6, 0, 0);
                    TextSize = 14;
                    Texto = Valor;
                    TextXAlignment = Enum.TextXAlignment.Left;
                    ZIndex = 25;
                    Pai = Botão;
                });

                Biblioteca:OnHighlight(Botão, Botão,
                    { BorderColor3 = 'AccentColor', ZIndex = 24 },
                    { BorderColor3 = 'OutlineColor', ZIndex = 23 }
                );

                local selecionado;

                se Info.Multi então
                    Selecionado = Dropdown.Value[Valor];
                senão
                    Selecionado = Dropdown.Value == Valor;
                fim;

                Tabela de funções:UpdateButton()
                    se Info.Multi então
                        Selecionado = Dropdown.Value[Valor];
                    senão
                        Selecionado = Dropdown.Value == Valor;
                    fim;

                    ButtonLabel.TextColor3 = Selecionado e Library.AccentColor ou Library.FontColor;
                    Library.RegistryMap[ButtonLabel].Properties.TextColor3 = Selecionado e 'AccentColor' ou 'FontColor';
                fim;

                ButtonLabel.InputBegan:Connect(function(Input)
                    se Input.UserInputType == Enum.UserInputType.MouseButton1 então
                        local Try = não selecionado;

                        se Dropdown:GetActiveValues() == 1 e (não Try) e (não Info.AllowNull) então
                        senão
                            se Info.Multi então
                                Selecionado = Tentar;

                                se selecionado então
                                    Dropdown.Value[Valor] = verdadeiro;
                                senão
                                    Dropdown.Value[Valor] = nil;
                                fim;
                            senão
                                Selecionado = Tentar;

                                se selecionado então
                                    Dropdown.Value = Valor;
                                senão
                                    Dropdown.Value = nil;
                                fim;

                                for _, OtherButton in next, Buttons do
                                    OtherButton: Botão Atualizar();
                                fim;
                            fim;

                            Tabela:UpdateButton();
                            Menu suspenso:Exibir();

                            se suspenso.Alterado então
                                Dropdown.Changed();
                            fim;

                            Biblioteca:AttemptSave();
                        fim;
                    fim;
                fim);

                Tabela:UpdateButton();
                Menu suspenso:Exibir();

                Botões[Botão] = Tabela;
            fim;

            local Y = math.clamp(Contagem * 20, 0, MAX_DROPDOWN_ITEMS * 20) + 1;
            ListOuter.Size = UDim2.new(1, -8, 0, Y);
            Scrolling.CanvasSize = UDim2.new(0, 0, 0, (Contagem * 20) + 1);

            -- ListOuter.Size = UDim2.new(1, -8, 0, (#Values ​​* 20) + 2);
        fim;

        Função Dropdown:OpenDropdown()
            ListOuter.Visible = verdadeiro;
            Library.OpenedFrames[ListOuter] = verdadeiro;
            DropdownArrow.Rotation = 180;
        fim;

        Função Dropdown:CloseDropdown()
            ListOuter.Visible = false;
            Library.OpenedFrames[ListOuter] = nil;
            DropdownArrow.Rotation = 0;
        fim;

        Menu suspenso de função: OnChanged(Func)
            Dropdown.Changed = Função;
            Função();
        fim;

        Menu suspenso de função:SetValue(Val)
            se Dropdown.Multi então
                nTabela local = {};

                for Value, Bool in next, Val do
                    se table.find(Dropdown.Values, Value) então
                        nTabela[Valor] = verdadeiro
                    fim;
                fim;

                Dropdown.Value = nTabela;
            senão
                se (não Val) então
                    Dropdown.Value = nil;
                elseif table.find(Dropdown.Values, Val) então
                    Dropdown.Value = Val;
                fim;
            fim;

            Lista suspensa:SetValues();
            Menu suspenso:Exibir();
            
            se Dropdown.Changed então Dropdown.Changed() end
        fim;

        DropdownOuter.InputBegan:Connect(function(Input)
            se Input.UserInputType == Enum.UserInputType.MouseButton1 e não Library:MouseIsOverOpenedFrame() então
                se ListOuter.Visible então
                    Lista suspensa: Fechar lista suspensa();
                senão
                    Menu suspenso:OpenDropdown();
                fim;
            fim;
        fim);

        InputService.InputBegan:Connect(function(Input)
            se Input.UserInputType == Enum.UserInputType.MouseButton1 então
                local AbsPos, AbsSize = ListOuter.AbsolutePosition, ListOuter.AbsoluteSize;

                se Mouse.X < AbsPos.X ou Mouse.X > AbsPos.X + AbsSize.X
                    ou Mouse.Y < (AbsPos.Y - 20 - 1) ou Mouse.Y > AbsPos.Y + AbsSize.Y então

                    Lista suspensa: Fechar lista suspensa();
                fim;
            fim;
        fim);

        Lista suspensa:SetValues();
        Menu suspenso:Exibir();

        if type(Info.Default) == 'string' então
            Info.Default = table.find(Dropdown.Values, Info.Default)
        fim

        se Info.Padrão então
            se Info.Multi então
                Dropdown.Value[Dropdown.Values[Info.Default]] = verdadeiro;
            senão
                Dropdown.Value = Dropdown.Values[Info.Padrão];
            fim;

            Lista suspensa:SetValues();
            Menu suspenso:Exibir();
        fim;

        Groupbox:AddBlank(Info.BlankSize or 5);
        Caixa de Grupo:Redimensionar();

        Opções[Idx] = Lista suspensa;

        retornar menu suspenso;
    fim;

    BaseGroupbox.__index = Funções;
    BaseGroupbox.__namecall = function(Tabela, Chave, ...)
        return Funcs[Chave](...);
    fim;
fim;

-- <Criar outros elementos de interface do usuário>
Faz
    Library.NotificationArea = Library:Create('Frame', {
        BackgroundTransparency = 1;
        Posição = UDim2.new(0, 0, 0, 40);
        Tamanho = UDim2.new(0, 300, 0, 200);
        ZIndex = 100;
        Pai = ScreenGui;
    });

    Biblioteca:Create('UIListLayout', {
        Preenchimento = UDim.new(0, 4);
        FillDirection = Enum.FillDirection.Vertical;
        SortOrder = Enum.SortOrder.LayoutOrder;
        Pai = Library.NotificationArea;
    });

    local WatermarkOuter = Library:Create('Frame', {
        BordaCor3 = Cor3.new(0, 0, 0);
        Posição = UDim2.new(0, 100, 0, -25);
        Tamanho = UDim2.new(0, 213, 0, 20);
        ZIndex = 200;
        Visível = falso;
        Pai = ScreenGui;
    });

    local WatermarkInner = Library:Create('Frame', {
        BackgroundColor3 = Biblioteca.MainColor;
        BorderColor3 = Biblioteca.AccentColor;
        BorderMode = Enum.BorderMode.Inset;
        Tamanho = UDim2.new(1, 0, 1, 0);
        ZIndex = 201;
        Pai = WatermarkOuter;
    });

    Biblioteca:AddToRegistry(WatermarkInner, {
        BorderColor3 = 'AccentColor';
    });

    local InnerFrame = Library:Create('Frame', {
        BackgroundColor3 = Color3.new(1, 1, 1);
        BorderSizePixel = 0;
        Posição = UDim2.new(0, 1, 0, 1);
        Tamanho = UDim2.new(1, -2, 1, -2);
        ZIndex = 202;
        Pai = WatermarkInner;
    });

    local Gradient = Library:Create('UIGradient', {
        Cor = ColorSequence.new({
            ColorSequenceKeypoint.new(0, Library:GetDarkerColor(Library.MainColor)),
            ColorSequenceKeypoint.new(1, Library.MainColor),
        });
        Rotação = -90;
        Pai = InnerFrame;
    });

    Biblioteca:AddToRegistry(Gradient, {
        cor = função()
            return ColorSequence.new({
                ColorSequenceKeypoint.new(0, Library:GetDarkerColor(Library.MainColor)),
                ColorSequenceKeypoint.new(1, Library.MainColor),
            });
        fim
    });

    local WatermarkLabel = Biblioteca:CreateLabel({
        Posição = UDim2.new(0, 5, 0, 0);
        Tamanho = UDim2.new(1, -4, 1, 0);
        TextSize = 14;
        TextXAlignment = Enum.TextXAlignment.Left;
        ZIndex = 203;
        Pai = InnerFrame;
    });

    Library.Watermark = WatermarkOuter;
    Library.WatermarkText = WatermarkLabel;
    Biblioteca:MakeDraggable(Library.Watermark);



    local KeybindOuter = Library:Create('Frame', {
        AnchorPoint = Vector2.new(0, 0.5);
        BordaCor3 = Cor3.new(0, 0, 0);
        Posição = UDim2.new(0, 10, 0,5, 0);
        Tamanho = UDim2.new(0, 210, 0, 20);
        Visível = falso;
        ZIndex = 100;
        Pai = ScreenGui;
    });

    local KeybindInner = Library:Create('Frame', {
        BackgroundColor3 = Biblioteca.MainColor;
        BorderColor3 = Library.OutlineColor;
        BorderMode = Enum.BorderMode.Inset;
        Tamanho = UDim2.new(1, 0, 1, 0);
        ZIndex = 101;
        Pai = KeybindOuter;
    });

    Biblioteca:AddToRegistry(KeybindInner, {
        BackgroundColor3 = 'MainColor';
        BorderColor3 = 'Cor do Contorno';
    }, verdadeiro);

    local ColorFrame = Library:Create('Frame', {
        BackgroundColor3 = Biblioteca.AccentColor;
        BorderSizePixel = 0;
        Tamanho = UDim2.new(1, 0, 0, 2);
        ZIndex = 102;
        Pai = KeybindInner;
    });

    Biblioteca:AddToRegistry(ColorFrame, {
        BackgroundColor3 = 'AccentColor';
    }, verdadeiro);

    local KeybindLabel = Biblioteca:CreateLabel({
        Tamanho = UDim2.new(1, 0, 0, 20);
        Posição = UDim2.fromOffset(5, 2),
        TextXAlignment = Enum.TextXAlignment.Left,
        
        Text = 'Keybinds';
        ZIndex = 104;
        Pai = KeybindInner;
    });

    local KeybindContainer = Library:Create('Frame', {
        BackgroundTransparency = 1;
        Tamanho = UDim2.new(1, 0, 1, -20);
        Posição = UDim2.new(0, 0, 0, 20);
        ZIndex = 1;
        Pai = KeybindInner;
    });

    Biblioteca:Create('UIListLayout', {
        FillDirection = Enum.FillDirection.Vertical;
        SortOrder = Enum.SortOrder.LayoutOrder;
        Pai = KeybindContainer;
    });

    Biblioteca:Create('UIPadding', {
        PaddingLeft = UDim.new(0, 5),
        Pai = KeybindContainer,
    })

    Library.KeybindFrame = KeybindOuter;
    Library.KeybindContainer = KeybindContainer;
    Biblioteca:MakeDraggable(KeybindOuter);
fim;

biblioteca de funções:SetWatermarkVisibility(Bool)
    Library.Watermark.Visible = Bool;
fim;

biblioteca de funções:SetWatermark(Text)
    local X, Y = Library:GetTextBounds(Text, Enum.Font.Code, 14);
    Library.Watermark.Size = UDim2.new(0, X + 15, 0, (Y * 1.5) + 3);
    Biblioteca:SetWatermarkVisibility(true)

    Library.WatermarkText.Text = Texto;
fim;

Biblioteca de funções: Notificar (Texto, Hora)
    local XSize, YSize = Library:GetTextBounds(Text, Enum.Font.Code, 14);

    YTamanho = YTamanho + 7

    local NotifyOuter = Library:Create('Frame', {
        BordaCor3 = Cor3.new(0, 0, 0);
        Posição = UDim2.new(0, 100, 0, 10);
        Tamanho = UDim2.new(0, 0, 0, YTamanho);
        ClipesDescendentes = true;
        ZIndex = 100;
        Pai = Library.NotificationArea;
    });

    local NotifyInner = Library:Create('Frame', {
        BackgroundColor3 = Biblioteca.MainColor;
        BorderColor3 = Library.OutlineColor;
        BorderMode = Enum.BorderMode.Inset;
        Tamanho = UDim2.new(1, 0, 1, 0);
        ZIndex = 101;
        Pai = NotifyOuter;
    });

    Biblioteca:AddToRegistry(NotifyInner, {
        BackgroundColor3 = 'MainColor';
        BorderColor3 = 'Cor do Contorno';
    }, verdadeiro);

    local InnerFrame = Library:Create('Frame', {
        BackgroundColor3 = Color3.new(1, 1, 1);
        BorderSizePixel = 0;
        Posição = UDim2.new(0, 1, 0, 1);
        Tamanho = UDim2.new(1, -2, 1, -2);
        ZIndex = 102;
        Pai = NotifyInner;
    });

    local Gradient = Library:Create('UIGradient', {
        Cor = ColorSequence.new({
            ColorSequenceKeypoint.new(0, Library:GetDarkerColor(Library.MainColor)),
            ColorSequenceKeypoint.new(1, Library.MainColor),
        });
        Rotação = -90;
        Pai = InnerFrame;
    });

    Biblioteca:AddToRegistry(Gradient, {
        cor = função()
            return ColorSequence.new({
                ColorSequenceKeypoint.new(0, Library:GetDarkerColor(Library.MainColor)),
                ColorSequenceKeypoint.new(1, Library.MainColor),
            });
        fim
    });

    local NotifyLabel = Biblioteca:CreateLabel({
        Posição = UDim2.new(0, 4, 0, 0);
        Tamanho = UDim2.new(1, -4, 1, 0);
        Texto = Texto;
        TextXAlignment = Enum.TextXAlignment.Left;
        TextSize = 14;
        ZIndex = 103;
        Pai = InnerFrame;
    });

    local LeftColor = Library:Create('Frame', {
        BackgroundColor3 = Biblioteca.AccentColor;
        BorderSizePixel = 0;
        Posição = UDim2.new(0, -1, 0, -1);
        Tamanho = UDim2.new(0, 3, 1, 2);
        ZIndex = 104;
        Pai = NotifyOuter;
    });

    Biblioteca:AddToRegistry(LeftColor, {
        BackgroundColor3 = 'AccentColor';
    }, verdadeiro);

    pcall(NotifyOuter.TweenSize, NotifyOuter, UDim2.new(0, XSize + 8 + 4, 0, YSize), 'Out', 'Quad', 0.4, true);

    tarefa.spawn(função()
        espera(Tempo ou 5);

        pcall(NotifyOuter.TweenSize, NotifyOuter, UDim2.new(0, 0, 0, YSize), 'Out', 'Quad', 0.4, true);

        espera(0.4);

        NotifyOuter:Destroy();
    fim);
fim;

biblioteca de funções:CreateWindow(...)
    local Argumentos = { ... }
    local Config = { AnchorPoint = Vector2.zero }

    if tipo(...) == 'tabela' então
        Configuração = ...;
    senão
        Config.Title = Argumentos[1]
        Config.AutoShow = Argumentos[2] ou falso;
    fim
    
    if type(Config.Title) ~= 'string' then Config.Title = 'Sem título' end
    
    if typeof(Config.Position) ~= 'UDim2' então Config.Position = UDim2.fromOffset(175, 50) end
    if typeof(Config.Size) ~= 'UDim2' então Config.Size = UDim2.fromOffset(550, 600) end

    se Config.Center então
        Config.AnchorPoint = Vector2.new(0.5, 0.5)
        Config.Position = UDim2.fromScale(0.5, 0.5)
    fim

    janela local = {
        Guias = {};
    };

    local Outer = Biblioteca:Create('Frame', {
        AnchorPoint = Config.AnchorPoint,
        BackgroundColor3 = Color3.new(0, 0, 0);
        BorderSizePixel = 0;
        Posição = Config.Posição,
        Tamanho = Config.Tamanho,
        Visível = falso;
        ZIndex = 1;
        Pai = ScreenGui;
    });

    Biblioteca:MakeDraggable(Outer, 25);

    local Inner = Biblioteca:Create('Frame', {
        BackgroundColor3 = Biblioteca.MainColor;
        BorderColor3 = Biblioteca.AccentColor;
        BorderMode = Enum.BorderMode.Inset;
        Posição = UDim2.new(0, 1, 0, 1);
        Tamanho = UDim2.new(1, -2, 1, -2);
        ZIndex = 1;
        Pai = Externo;
    });

    Biblioteca:AddToRegistry(Inner, {
        BackgroundColor3 = 'MainColor';
        BorderColor3 = 'AccentColor';
    });

    local WindowLabel = Biblioteca:CreateLabel({
        Posição = UDim2.new(0, 7, 0, 0);
        Tamanho = UDim2.new(0, 0, 0, 25);
        Text = Config.Title ou '';
        TextXAlignment = Enum.TextXAlignment.Left;
        ZIndex = 1;
        Pai = Interno;
    });

    local MainSectionOuter = Library:Create('Frame', {
        BackgroundColor3 = Biblioteca.BackgroundColor;
        BorderColor3 = Library.OutlineColor;
        Posição = UDim2.new(0, 8, 0, 25);
        Tamanho = UDim2.new(1, -16, 1, -33);
        ZIndex = 1;
        Pai = Interno;
    });

    Biblioteca:AddToRegistry(MainSectionOuter, {
        BackgroundColor3 = 'BackgroundColor';
        BorderColor3 = 'Cor do Contorno';
    });

    local MainSectionInner = Library:Create('Frame', {
        BackgroundColor3 = Biblioteca.BackgroundColor;
        BordaCor3 = Cor3.new(0, 0, 0);
        BorderMode = Enum.BorderMode.Inset;
        Posição = UDim2.new(0, 0, 0, 0);
        Tamanho = UDim2.new(1, 0, 1, 0);
        ZIndex = 1;
        Pai = MainSectionOuter;
    });

    Biblioteca:AddToRegistry(MainSectionInner, {
        BackgroundColor3 = 'BackgroundColor';
    });

    local TabArea = Library:Create('Frame', {
        BackgroundTransparency = 1;
        Posição = UDim2.new(0, 8, 0, 8);
        Tamanho = UDim2.new(1, -16, 0, 21);
        ZIndex = 1;
        Pai = MainSectionInner;
    });

    Biblioteca:Create('UIListLayout', {
        Preenchimento = UDim.new(0, 0);
        FillDirection = Enum.FillDirection.Horizontal;
        SortOrder = Enum.SortOrder.LayoutOrder;
        Pai = TabArea;
    });

    local TabContainer = Library:Create('Frame', {
        BackgroundColor3 = Biblioteca.MainColor;
        BorderColor3 = Library.OutlineColor;
        Posição = UDim2.new(0, 8, 0, 30);
        Tamanho = UDim2.new(1, -16, 1, -38);
        ZIndex = 2;
        Pai = MainSectionInner;
    });

    Biblioteca:AddToRegistry(TabContainer, {
        BackgroundColor3 = 'MainColor';
        BorderColor3 = 'Cor do Contorno';
    });

    função Window:SetWindowTitle(Title)
        WindowLabel.Text = Título;
    fim;

    função Janela:AddTab(Nome)
        guia local = {
            Caixas de grupo = {};
            Tabboxes = {};
        };

        local TabButtonWidth = Biblioteca:GetTextBounds(Nome, Enum.Font.Code, 16);

        local TabButton = Library:Create('Frame', {
            BackgroundColor3 = Biblioteca.BackgroundColor;
            BorderColor3 = Library.OutlineColor;
            Tamanho = UDim2.new(0, TabButtonWidth + 8 + 4, 1, 0);
            ZIndex = 1;
            Pai = TabArea;
        });

        Biblioteca:AddToRegistry(TabButton, {
            BackgroundColor3 = 'BackgroundColor';
            BorderColor3 = 'Cor do Contorno';
        });

        local TabButtonLabel = Biblioteca:CreateLabel({
            Posição = UDim2.new(0, 0, 0, 0);
            Tamanho = UDim2.new(1, 0, 1, -1);
            Texto = Nome;
            ZIndex = 1;
            Pai = TabButton;
        });

        Bloqueador local = Biblioteca:Create('Frame', {
            BackgroundColor3 = Biblioteca.MainColor;
            BorderSizePixel = 0;
            Posição = UDim2.new(0, 0, 1, 0);
            Tamanho = UDim2.new(1, 0, 0, 1);
            BackgroundTransparency = 1;
            ZIndex = 3;
            Pai = TabButton;
        });

        Biblioteca:AddToRegistry(Blocker, {
            BackgroundColor3 = 'MainColor';
        });

        local TabFrame = Library:Create('Frame', {
            BackgroundTransparency = 1;
            Posição = UDim2.new(0, 0, 0, 0);
            Tamanho = UDim2.new(1, 0, 1, 0);
            Visível = falso;
            ZIndex = 2;
            Pai = TabContainer;
        });

        local LeftSide = Library:Create('Frame', {
            BackgroundTransparency = 1;
            Posição = UDim2.new(0, 8, 0, 8);
            Tamanho = UDim2.new(0.5, -12, 0, 507);
            ZIndex = 2;
            Pai = TabFrame;
        });

        local RightSide = Library:Create('Frame', {
            BackgroundTransparency = 1;
            Posição = UDim2.new(0.5, 4, 0, 8);
            Tamanho = UDim2.new(0.5, -12, 0, 507);
            ZIndex = 2;
            Pai = TabFrame;
        });

        Biblioteca:Create('UIListLayout', {
            Preenchimento = UDim.new(0, 8);
            FillDirection = Enum.FillDirection.Vertical;
            SortOrder = Enum.SortOrder.LayoutOrder;
            Pai = Lado Esquerdo;
        });

        Biblioteca:Create('UIListLayout', {
            Preenchimento = UDim.new(0, 8);
            FillDirection = Enum.FillDirection.Vertical;
            SortOrder = Enum.SortOrder.LayoutOrder;
            Pai = Lado Direito;
        });

        função Aba:MostrarTab()
            for _, Tab in next, Window.Tabs do
                Aba:OcultarTab();
            fim;

            Blocker.BackgroundTransparency = 0;
            TabButton.BackgroundColor3 = Biblioteca.MainColor;
            Library.RegistryMap[TabButton].Properties.BackgroundColor3 = 'MainColor';
            TabFrame.Visible = verdadeiro;
        fim;

        função Tab:HideTab()
            Blocker.BackgroundTransparency = 1;
            TabButton.BackgroundColor3 = Biblioteca.BackgroundColor;
            Library.RegistryMap[TabButton].Properties.BackgroundColor3 = 'BackgroundColor';
            TabFrame.Visible = false;
        fim;

        guia de função:AdicionarGroupbox(Informações)
            caixa de grupo local = {};

            local BoxOuter = Library:Create('Frame', {
                BackgroundColor3 = Biblioteca.BackgroundColor;
                BorderColor3 = Library.OutlineColor;
                Tamanho = UDim2.new(1, 0, 0, 507);
                ZIndex = 2;
                Parent = Info.Side == 1 e LeftSide ou RightSide;
            });

            Biblioteca:AddToRegistry(BoxOuter, {
                BackgroundColor3 = 'BackgroundColor';
                BorderColor3 = 'Cor do Contorno';
            });

            local BoxInner = Library:Create('Frame', {
                BackgroundColor3 = Biblioteca.BackgroundColor;
                BordaCor3 = Cor3.new(0, 0, 0);
                BorderMode = Enum.BorderMode.Inset;
                Tamanho = UDim2.new(1, 0, 1, 0);
                ZIndex = 4;
                Pai = BoxOuter;
            });

            Biblioteca:AddToRegistry(BoxInner, {
                BackgroundColor3 = 'BackgroundColor';
            });

            local Highlight = Library:Create('Frame', {
                BackgroundColor3 = Biblioteca.AccentColor;
                BorderSizePixel = 0;
                Tamanho = UDim2.new(1, 0, 0, 2);
                ZIndex = 5;
                Pai = BoxInner;
            });

            Biblioteca:AddToRegistry(Destaque, {
                BackgroundColor3 = 'AccentColor';
            });

            local GroupboxLabel = Biblioteca:CreateLabel({
                Tamanho = UDim2.new(1, 0, 0, 18);
                Posição = UDim2.new(0, 4, 0, 2);
                TextSize = 14;
                Text = Info.Name;
                TextXAlignment = Enum.TextXAlignment.Left;
                ZIndex = 5;
                Pai = BoxInner;
            });

            local Container = Library:Create('Frame', {
                BackgroundTransparency = 1;
                Posição = UDim2.new(0, 4, 0, 20);
                Tamanho = UDim2.new(1, -4, 1, -20);
                ZIndex = 1;
                Pai = BoxInner;
            });

            Biblioteca:Create('UIListLayout', {
                FillDirection = Enum.FillDirection.Vertical;
                SortOrder = Enum.SortOrder.LayoutOrder;
                Pai = Contêiner;
            });

            função Groupbox: Redimensionar ()
                tamanho local = 0;

                para _, Elemento em seguida, Groupbox.Container:GetChildren() do
                    se não for Element:IsA('UIListLayout') então
                        Tamanho = Tamanho + Element.Size.Y.Offset;
                    fim;
                fim;

                BoxOuter.Size = UDim2.new(1, 0, 0, 20 + Tamanho + 2);
            fim;

            Groupbox.Container = Contêiner;
            setmetatable(Groupbox, BaseGroupbox);

            Caixa de Grupo:AdicionarEm Branco(3);
            Caixa de Grupo:Redimensionar();

            Tab.Groupboxes[Info.Name] = Caixa de Grupo;

            retornar caixa de grupo;
        fim;

        função Tab:AddLeftGroupbox(Name)
            return Tab:AddGroupbox({ Lado = 1; Nome = Nome; });
        fim;

        guia de função:AddRightGroupbox(Name)
            return Tab:AddGroupbox({ Lado = 2; Nome = Nome; });
        fim;

        função Tab:AddTabbox(Info)
            Tabbox local = {
                Guias = {};
            };

            local BoxOuter = Library:Create('Frame', {
                BackgroundColor3 = Biblioteca.BackgroundColor;
                BorderColor3 = Library.OutlineColor;
                Tamanho = UDim2.new(1, 0, 0, 0);
                ZIndex = 2;
                Parent = Info.Side == 1 e LeftSide ou RightSide;
            });

            Biblioteca:AddToRegistry(BoxOuter, {
                BackgroundColor3 = 'BackgroundColor';
                BorderColor3 = 'Cor do Contorno';
            });

            local BoxInner = Library:Create('Frame', {
                BackgroundColor3 = Biblioteca.BackgroundColor;
                BordaCor3 = Cor3.new(0, 0, 0);
                BorderMode = Enum.BorderMode.Inset;
                Tamanho = UDim2.new(1, 0, 1, 0);
                ZIndex = 4;
                Pai = BoxOuter;
            });

            Biblioteca:AddToRegistry(BoxInner, {
                BackgroundColor3 = 'BackgroundColor';
            });

            local Highlight = Library:Create('Frame', {
                BackgroundColor3 = Biblioteca.AccentColor;
                BorderSizePixel = 0;
                Tamanho = UDim2.new(1, 0, 0, 2);
                ZIndex = 10;
                Pai = BoxInner;
            });

            Biblioteca:AddToRegistry(Destaque, {
                BackgroundColor3 = 'AccentColor';
            });

            local TabboxButtons = Library:Create('Frame', {
                BackgroundTransparency = 1;
                Posição = UDim2.new(0, 0, 0, 1);
                Tamanho = UDim2.new(1, 0, 0, 18);
                ZIndex = 5;
                Pai = BoxInner;
            });

            Biblioteca:Create('UIListLayout', {
                FillDirection = Enum.FillDirection.Horizontal;
                HorizontalAlignment = Enum.HorizontalAlignment.Left;
                SortOrder = Enum.SortOrder.LayoutOrder;
                Pai = TabboxButtons;
            });

            função Tabbox:AddTab(Name)
                guia local = {};

                local Button = Library:Create('Frame', {
                    BackgroundColor3 = Biblioteca.MainColor;
                    BordaCor3 = Cor3.new(0, 0, 0);
                    Tamanho = UDim2.new(0.5, 0, 1, 0);
                    ZIndex = 6;
                    Pai = TabboxButtons;
                });

                Biblioteca:AddToRegistry(Botão, {
                    BackgroundColor3 = 'MainColor';
                });

                local ButtonLabel = Biblioteca:CreateLabel({
                    Tamanho = UDim2.new(1, 0, 1, 0);
                    TextSize = 14;
                    Texto = Nome;
                    TextXAlignment = Enum.TextXAlignment.Center;
                    ZIndex = 7;
                    Pai = Botão;
                });

                Bloco local = Biblioteca:Create('Frame', {
                    BackgroundColor3 = Biblioteca.BackgroundColor;
                    BorderSizePixel = 0;
                    Posição = UDim2.new(0, 0, 1, 0);
                    Tamanho = UDim2.new(1, 0, 0, 1);
                    Visível = falso;
                    ZIndex = 9;
                    Pai = Botão;
                });

                Biblioteca:AddToRegistry(Block, {
                    BackgroundColor3 = 'BackgroundColor';
                });

                local Container = Library:Create('Frame', {
                    Posição = UDim2.new(0, 4, 0, 20);
                    Tamanho = UDim2.new(1, -4, 1, -20);
                    ZIndex = 1;
                    Visível = falso;
                    Pai = BoxInner;
                });

                Biblioteca:Create('UIListLayout', {
                    FillDirection = Enum.FillDirection.Vertical;
                    SortOrder = Enum.SortOrder.LayoutOrder;
                    Pai = Contêiner;
                });

                aba de função:Mostrar()
                    for _, Tab in next, Tabbox.Tabs do
                        Aba:Ocultar();
                    fim;

                    Container.Visible = verdadeiro;
                    Block.Visible = true;

                    Button.BackgroundColor3 = Biblioteca.BackgroundColor;
                    Library.RegistryMap[Button].Properties.BackgroundColor3 = 'BackgroundColor';
                fim;

                função Aba:Ocultar()
                    Container.Visible = false;
                    Block.Visible = false;

                    Button.BackgroundColor3 = Biblioteca.MainColor;
                    Library.RegistryMap[Button].Properties.BackgroundColor3 = 'MainColor';
                fim;

                guia de função: Redimensionar ()
                    local TabCount = 0;

                    for _, Tab in next, Tabbox.Tabs do
                        TabCont = TabCont + 1;
                    fim;

                    for _, Button in next, TabboxButtons:GetChildren() do
                        se não Button:IsA('UIListLayout') então
                            Button.Size = UDim2.new(1 / TabCount, 0, 1, 0);
                        fim;
                    fim;

                    tamanho local = 0;

                    para _, Elemento em seguida, Tab.Container:GetChildren() faça
                        se não for Element:IsA('UIListLayout') então
                            Tamanho = Tamanho + Element.Size.Y.Offset;
                        fim;
                    fim;

                    se BoxOuter.Size.Y.Offset < 20 + Size + 2 então
                        BoxOuter.Size = UDim2.new(1, 0, 0, 20 + Tamanho + 2);
                    fim;
                fim;

                Button.InputBegan:Connect(function(Input)
                    se Input.UserInputType == Enum.UserInputType.MouseButton1 e não Library:MouseIsOverOpenedFrame() então
                        Aba:Mostrar();
                    fim;
                fim);

                Tab.Container = Contêiner;
                Tabbox.Tabs[Nome] = Guia;

                setmetatable(Tab, BaseGroupbox);

                Guia:AdicionarBranco(3);
                Aba:Redimensionar();

                se #TabboxButtons:GetChildren() == 2 então
                    Aba:Mostrar();
                fim;

                guia de retorno;
            fim;

            Tab.Tabboxes[Info.Name ou ''] = Tabbox;

            retornar Tabbox;
        fim;

        função Tab:AddLeftTabbox(Name)
            return Tab:AddTabbox({ Nome = Nome, Lado = 1; });
        fim;

        função Tab:AddRightTabbox(Name)
            return Tab:AddTabbox({ Nome = Nome, Lado = 2; });
        fim;

        TabButton.InputBegan:Connect(function(Input)
            se Input.UserInputType == Enum.UserInputType.MouseButton1 então
                Tab:MostrarTab();
            fim;
        fim);

        -- Esta foi a primeira guia adicionada, então a mostramos por padrão.
        se #TabContainer:GetChildren() == 1 então
            Tab:MostrarTab();
        fim;

        Window.Tabs[Nome] = Guia;
        guia de retorno;
    fim;

    local ModalElement = Library:Create('TextButton', {
        BackgroundTransparency = 1;
        Tamanho = UDim2.new(0, 0, 0, 0);
        Visível = verdadeiro;
        Texto = '';
        Modal = falso;
        Pai = ScreenGui;
    });

    função Biblioteca.Toggle()
        Exterior.Visível = não Exterior.Visível;
        ModalElement.Modal = Exterior.Visível;

        local oIcon = Mouse.Icon;
        estado local = InputService.MouseIconEnabled;

        local Cursor = Drawing.new('Triângulo');
        Cursor.Thickness = 1;
        Cursor.Preenchido = verdadeiro;

        enquanto Outer.Visible faça
            local mPos = workspace.CurrentCamera:WorldToViewportPoint(Mouse.Hit.p);

            Cursor.Color = Library.AccentColor;
            Cursor.PointA = Vector2.new(mPos.X, mPos.Y);
            Cursor.PointB = Vector2.new(mPos.X, mPos.Y) + Vector2.new(6, 14);
            Cursor.PointC = Vector2.new(mPos.X, mPos.Y) + Vector2.new(-6, 14);

            Cursor.Visible = não InputService.MouseIconEnabled;

            RenderStepped:Wait();
        fim;

        Cursor:Remover();
    fim

    Library:GiveSignal(InputService.InputBegan:Connect(function(Input, Processed)
        if type(Library.ToggleKeybind) == 'table' and Library.ToggleKeybind.Type == 'KeyPicker' então
            se Input.UserInputType == Enum.UserInputType.Keyboard e Input.KeyCode.Name == Library.ToggleKeybind.Value então
                task.spawn(Library.Toggle)
            fim
        elseif Input.KeyCode == Enum.KeyCode.Insert ou (Input.KeyCode == Enum.Insert e (não processado)) então
            task.spawn(Library.Toggle)
        fim
    fim))

    se Config.AutoShow então task.spawn(Library.Toggle) end

    Window.Holder = Externo;

    Janela de retorno;
fim;

biblioteca de retorno
